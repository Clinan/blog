# 阿里亿级高并发系统设计

## 数据库

### 数据库连接池

最小连接数和最大连接数

- 如果当前连接数小于最小连接数，则创建新的连接处理数据库请求
- 如果连接池中有空闲连接则复用空闲连接
- 如果空闲池中没有连接并且连接数小于最大连接数，则创建新的连接处理请求
- 如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间，等待空闲连接可用，超时则抛出错误。



### 读写分离

- 一般一个主库最多挂3~5个从库



### 写入数据量增加时，如何实现分库分表

#### 垂直分表



#### 水平分表



#### 发号器

雪花算法



## 缓存

### 缓存穿透解决方案

缓存穿透是指从缓存中没有查到数据，而不得不从数据库中获取。

### 回种空值

当从数据库中查询到空值或发生异常时，我们可以向缓存中回种一个空值，但因为空值不是准确的业务数据，所以我们会给这个空值加一个比较短的过期时间，让空值能够在短时间内快速淘汰。

缺点：当数据量很大的时候，会消耗很多无意义的内存。



### 布隆过滤器

用来判断一个值是否在集合中，由一个二进制数组和Hash算法组成。实际应用来判断一值是否存在数据库中。

优点：拥有极高的性能，无论是写入还是读取，时间复杂度都是O(1)

缺点：

- 判断元素是否在集合中有一定的错误几率，它会把不在集合中的元素判断为在集合中。因为hash碰撞。
  - 解决方案使用多个算法计算多个不同的hash，只有所有hash值对应数组的值都为1，才是存在。
- 不支持删除元素
  - 不是bit数组，而是引用计数。多了一个+1，少了-1。且一般来说存的一般不会删除的数据。

### 极热点场景

一个极热点的缓存项，一旦失效会有大量的请求穿透到数据库，会对数据库造成很大的压力。

**解决方案** 

1. 在代码中，控制在某一热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而直接返回。
2. 通过在`memcached`或者`Redis`中设置分布式锁，只有获取到锁的请求才能够穿透到数据库。分布式锁的实现：比方说一个ID=1的用户是热点用户，当他的用户信息缓存失效后，我们需要从数据库重新加载数据时，先向`Memcached`写入一个`Key=lock.1`的缓存项，加载完后就删除。另外的线程发现有缓存，就会直接使用这个缓存，就不会穿透到数据库了。





## 消息队列

1. 流量削峰
2. 应用解耦
3. 异步处理
4. 消息通信

> **大佬理解：消息队列是一个暂存数据的容器，是一个平衡低速系统和高速系统处理任务时间差的工具。**

### 秒杀系统

**削去秒杀场景下的峰值写流量**

思路是：将秒杀请求暂存在消息队列中，然后业务服务器响应用户“秒杀结算中”。队列处理机处理处理秒杀，并持久化到数据库。

![](https://cdn.clinan.xyz/mq1.png)

**通过异步处理简化秒杀请求中的业务流程**

购买流程里，有主要和次要的业务逻辑。在这里主要的逻辑是生成订单，扣减库存；次要的是发放优惠券，增加用户的积分。

![](https://cdn.clinan.xyz/mq2.png)

**解耦实现秒杀系统模块之间松耦合**

可以降低业务系统和数据系统的直接耦合度



### 如何保证消息只被消费一次（幂等性）

消息丢失的三个场景

#### 1. 消息从生产者写入消息队列的过程

采用消息重传的方案，发现消息发送超时后，将消息重传，不能无限次重传。2~3次即可



#### 2.消息在消息队列中的存储过程

集群部署，主从集群。部署多个副本备份数据，保证消息数据尽量不丢失。

#### 3.信息被消费者消费的过程

消息消费分为三步，接收消息，处理消息，更新消息进度。

如果消息处理后，系统正好宕机了，消息服务器就会重传，但是这样可能会导致消息被多次消费。

**解决方案：**

- 对于MQ，每个生产者有一个唯一ID+消息的ID，消息队列判断同一个系统最后一个消息ID一样，服务端会自动丢弃

- 对于消费者：**乐观锁，加一个version**





