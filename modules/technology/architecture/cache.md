# 缓存

## 缓存读写（缓存一致性）

### 旁路缓存

**读策略**

1. 从缓存中读取数据
2. 如果缓存命中则直接返回数据
3. 缓存miss，则从数据库中查询数据

**写策略**

1. 更新数据库中的数据
2. 删除缓存记录

### 写穿/读穿策略



## 缓存的高可用

### 客户端

在客户端方案中，你需要关注缓存的写和读两个方面

- 写入数据时，需要把缓存的数据写入到多个缓存节点中，这叫**数据分片**
- 读取数据时，可以利用多组的缓存做容错，提升缓存系统的可用性。关于读数据，可以使用两种策略
  - 主从
  - 多副本

#### 数据分片

数据分片算法主要有**Hash分片**和**一致性Hash分片**

**Hash分片**

Hash分片就是对缓存的Key做哈希计算，然后对总的缓存节点取余。

比如我们有3个缓存节点作为一个缓存集群，当有新的数据写入的时候，先对这个key做比如CRC32等hash算法生成Hash值，然后对Hash值对3取余，得到的就是要存入的缓存节点的序号。

- **优点**

  简单和容易理解，

- **缺点**

  当增加和减少缓存节点的时候，缓存总的节点个数变化造成计算出来的节点序号发生变化，从而导致缓存失效或不可用。

- **建议**

  如果采用这种方法，最好建立在你对于这组缓存命中率下降不敏感，比如还有另外一层缓存兜底的情况下。

**一致性Hash分片**

一致性分片可以很好的解决增加和删除节点时，命中率下降的问题。

**一致性hash虚拟节点**

极端情况下，比如三个节点ABC承担整体的访问，每个节点的访问量平均，A故障后，B将承受双倍的压力（A和B的全部请求，当B承担不了流量Crash后，C也将因为承担原先三倍的流量而Crash，这就造成了整体缓存系统的雪崩。

在一致性Hash算法中引入**虚拟节点**的概念。它将一个节点计算多个Hash值，分散到圆环的不同位置，这样实现了数据的平均，当某一个节点故障或者退出的时候，它原先承担的Key将以更将平均的方式分配到其他节点上。从而避免雪崩。

**脏数据问题，使用一致性Hash算法一定要设置过期时间**



### 代理

1. `facebook`的`mcrouter`
2. `twitter`的`Twemproxy`
3. 豌豆荚的`Codis`



### 服务器端

主要指redis的sentinel高可用解决方案。

![](https://cdn.clinan.xyz/redis-sentinel.png)



## 缓存问题

### 缓存雪崩

#### 现象

指缓存中的数据大批量到过期时间，而查询量巨大，引起数据库压力过大或宕机。

#### 解决方案

1. 缓存数据的过期时间要加上随机值，防止同一时间大量数据过期现象发生。
2. 如果缓存是分布式部署。将热点数据均匀分布在不同的缓存数据库中。
3. 设置热点数据永不过期。

### 缓存穿透

#### 现象

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

#### 解决方案

1. 如果可以将ID指定在有效范围内的才能访问数据库。
2. 布隆过滤器，一个byte数组，根据数据量多少决定大小。
3. 回种空值。

### 缓存击穿（极热点数据）（狗桩效应）

#### 现象

是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

#### 解决方案

1. 在某一个热点缓存项失效后启动一个后台线程，穿透到数据库。将数据加载到缓存中，在缓存未加载之前，所有请求直接返回。
2. 在redis中设置分布式锁，只有获取到锁的请求才能穿透到数据库。

