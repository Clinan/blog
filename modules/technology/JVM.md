# JAVA SE8虚拟机规范

## 类型
### 整数类型
| 类型  | 说明                      | byte字节数 | 默认值 | 范围            |
| ----- | ------------------------- | ---------- | ------ | --------------- |
| byte  | 8bit的二进制补码表示      | 1          | 0      | -2^7~ (2^7)-1   |
| short | 16bit的二进制补码表示     | 2          | 0      | -2^15~ (2^15)-1 |
| int   | 32bit的二进制补码表示     | 4          | 0      | -2^31~ (2^31)-1 |
| long  | 64bit的二进制补码表示     | 8          | 0      | -2^63~ (2^63)-1 |
| char  | from 0 to 65535 inclusive | 4          |        | 0~2^16-1        |

### 浮点数类型



### 返回地址，The returnAddress Type and Values
返回地址，指令`jsr`, `ret`, `and`和`jsr_w`会使用到returnAddress，returnAddress的值是指向操作码的指针，
与原始类型不同，returnAddress不与任何Java编程类型相对应，并且不能由正在运行的程序更改。说白了就是一种类型


### boolean类型
尽管JVM虚拟机定义了boolean类型，但是对它的支持很有限，并且没有专门针对boolean的操作指令，
实际上，boolean类型被编译为int类型。 
对于boolean类型数组，实际上创建的数组是byte类型的，使用`baload`和`bastore`指令进行操作和存储 
在oracle虚拟机中，boolean数组就是byte数组，每个boolean元素就是一个byte，占用8个字节。 
并且java虚拟机声明1为true,0为false,如果要是int类型的话，也必须是0或1。


### 引用类型 Reference Types and Values
引用类型有三种，Interface types, Class types, Array types。它们的值分别引用动态创建的类实例，数组或实现接口的类实例或数组。


## 运行数据区

### 程序计数器
每个JAVA线程都有自己的程序计数器寄存器，每个java虚拟机线程都在执行单个方法的代码，即该线程的当前方法。 
如果不是native方法，则这个计数器包含当前正在执行的Java虚拟机指令的地址（运行到哪一行代码）。 
如果是native方法，则计数器的值是空的（未定义）。如果计数器的长度足够长，可以在特定平台上保存一些额外的信息，如returnAddress或是一个native pointer


### java虚拟机栈（Java Virtual Machine Stacks）
每个Java线程都有一个自己的虚拟机栈，并且和线程同时创建。虚拟机栈保存的是栈帧（stack frame）。因为对于虚拟机栈，除了入栈出栈外，从不直接操作虚拟机栈，所以可以从堆中分配栈帧给虚拟机栈。java虚拟机栈不必是连续的。 
可以是固定大小，也可以是动态的。hotspot中是固定大小的。 
Java虚拟机实现可以为程序员或用户提供对Java虚拟机堆栈的初始大小的控制，并且在动态扩展或收缩Java虚拟机堆栈的情况下，可以控制最大和最小。


### 堆（heap）
Java虚拟机具有一个所有线程之间共享的堆，堆是运行时数据区，从中分配**所有类实例和数组的内存。** 
堆的大小是可以固定的，可以根据需要进行调整堆的大小。 
如果堆内存不够用，会触发OOM异常



## HOTSPOT垃圾收集算法细节

### 根节点（GC Root）枚举

为了加快枚举速度，避免对每一个方法的对象栈进行轮询，设置了保存这些引用对象的数据结构OopMap，用于一次性读取引用对象。

- OopMap，在加载动作完成的时候，虚拟机就会把对象内什么偏移量上什么类型的数据计算出来，在JIT过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用；这个特定的位置被称为安全点（safePoint）。记录这个数据的数据结构在hotspot中被称为OopMap
- JNI(java native interface)方法使用句柄调用java对象，java对象调用JNI也要将自身包装为句柄调用



### 安全点（SafePint）

安全点一般设置在

- 方法返回之前/方法调用的call命令之后
- 循环的末尾
- 可能抛异常的位置

如果设置了安全点，程序执行中就会涉及到中断，主动终端和被动终端。hotspot中使用的是主动中断。主动式中断不需要对每个线程进行操作，仅仅设置一个标志位，各个线程执行过程中会不停的主动轮询这个标志位，一旦发现标志位为True，就自己在最近的安全点主动中断挂起。轮询标志的地方和安全点是重合的。hotspot才有内存保护陷阱的方式，将标志位的内存设置为不可读，线程便会挂起等待，这样仅通过一条汇编指令便完成了标志位轮询和主动中断挂起。

### 安全区域

针对没有执行的代码，如用户线程处于sleep,blacked状态时，无法执行到安全点。当用户线程执行到安全区域时，会标志自己进入到了安全区域，根节点枚举便不去管进入安全区域的线程，因为在安全区域中的任意地方收集垃圾都是安全的。一旦线程要退出安全区域，则需要判断是否在进行根节点枚举，有则等待根节点枚举结束。

### 记忆集和卡表

记忆集，是为了对象跨代引用带来的问题。卡表是记忆集最常见的实现

字节数组`CARD_TABLE`的每一个元素对应着其标识的内存区域中一块特定大小的内存块（卡页CardPage），Hotspot的卡页为2的9次幂等于512字节。

一个卡页中不止包含一个对象，只要卡页中存在至少一个对象存在跨代指针，那就将对应卡表的数组元素的值标识为1，称这个元素为脏（dirty），垃圾收集时，将含有跨代指针的卡页加入GCRoot中一并被扫描。



### 写屏障

解决谁来维护卡表，如何把卡页变脏的问题。





### 并发的可达性分析





## 收集器

### serial

- 标记-整理算法，将已用的内存都整理到堆的前面
- 标记-复制算法，将已用的内存都复制到另外的survivor
- 新生代采用标志-复制算法，老年代采用标记-整理算法

![](https://cdn.clinan.xyz/serial&serialOld.png)



### ParNew

- serial的多线程版本

- 

![](https://cdn.clinan.xyz/parNew&serialOld.png)



## JVM 类加载



### 类的生命周期

加载-（验证-准备-解析）[连接]-初始化-使用-卸载

#### 初始化时机

1. new对象的时候，读取静态字段的时候（static final修饰除外，因为在编译期将结果放置到常量池中了），调用静态方法的时候
2. 使用反射调用的时候
3. 初始化一个类的时候，发现父类还没有初始化，则先初始化父类
4. 当虚拟机启动的时候，先初始化主类
5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解 析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句
   柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当接口定义了default方法时，如果这个接口的实现类发生了初始化，那该接口要在类之前被初始化



### 加载



### 验证

- 文件格式验证
- 元数据验证
  - 这个类是否有父类（除了java.lang.Object
  - 是否继承了final类
  - 如果不是抽象类，是否实现了所有接口或抽象类方法
  - 是否出现不正确的覆盖字段或方法重载
- 符号引用验证（import 是否有，可访问性）

> 可以通过 -Xverify:none 来关闭验证，加快加载的速度

### 准备



​				

### 解析





1、Java代码是怎么变成字节码的，字节码又是怎么进入JVM的？（b）
2、JVM是怎么执行字节码的？哪些数据放在栈？哪些数据放在堆？（t）
3、如何做JVM的性能调优，具体怎么操作或怎么配置？（a）
4、实际开发工作中怎么监控JVM的工作情况？怎么定位那些bug？定位到了怎么解决他们？（a）
5、你做过JVM 参数调优和参数配置吗？请问如何查看 JVM 系统默认值？（a）
6、JVM内存泄漏与内存溢出的区别，怎么排查内存泄漏？（mt）
7、一个亿级流量系统，让它几乎不发生Full GC。你来进行JVM调优，怎么做？（a）